#!/usr/bin/env python3
"""
IAM Remediation Template Generator
Creates Terraform templates for IAM remediation based on findings
"""

from datetime import datetime, timezone, UTC
import json
import re
from typing import Dict, List, Any, Union


def matches_action_pattern(action_pattern: str, action: str) -> bool:
    """Check if an action matches a pattern (supports wildcards)"""
    # Escape special regex characters and replace * with .*
    pattern = re.escape(action_pattern).replace(r'\*', '.*')
    return bool(re.fullmatch(pattern, action))


class RemediationGenerator:
    def __init__(self, entitlement_report=None):
        self.entitlement_report = entitlement_report or {}
        self.iam = None  # Will be set by boto3 session
        self.organizations = None  # Will be set by boto3 session

    def generate_terraform_templates(self, output_dir: str = 'remediation_templates') -> None:
        """Generate Terraform templates for remediation"""
        import os
        os.makedirs(output_dir, exist_ok=True)

        findings = self.entitlement_report.get('findings', {})

        # Generate templates for each finding type
        self._generate_least_privilege_templates(findings, output_dir)
        self._generate_trust_policy_templates(findings, output_dir)
        self._generate_cleanup_templates(findings, output_dir)

        print(f"âœ… Terraform remediation templates generated in: {output_dir}")

    def _generate_least_privilege_templates(self, findings: Dict, output_dir: str) -> None:
        """Generate least-privilege policy templates"""
        over_privileged = findings.get('over_privileged_roles', [])
        risky_permissions = findings.get('risky_permissions', [])

        if over_privileged or risky_permissions:
            template = self._create_least_privilege_template(over_privileged + risky_permissions)
            with open(f'{output_dir}/least_privilege_policies.tf', 'w') as f:
                f.write(template)

    def _create_least_privilege_template(self, findings: List[Dict]) -> str:
        """Create Terraform template for least-privilege policies"""
        template = '''# Least Privilege IAM Policies
# Generated by CloudGuardStack IAM Entitlement Scanner
# Replace existing over-privileged policies with these least-privilege alternatives

'''

        for finding in findings:
            entity_name = finding.get('entity_name')
            entity_type = finding.get('entity_type')

            if entity_type == 'role':
                template += f'''
# Least privilege policy for {entity_name}
resource "aws_iam_role_policy" "{entity_name.replace('-', '_')}_least_privilege" {{
  name = "{entity_name}-least-privilege"
  role = aws_iam_role.{entity_name}.id

  policy = jsonencode({{
    Version = "2012-10-17"
    Statement = [
      {{
        Effect = "Allow"
        Action = [
          # TODO: Add only required actions based on usage patterns
          # Remove administrative and risky actions
          "s3:GetObject",
          "s3:ListBucket"
        ]
        Resource = [
          # TODO: Specify exact resources needed
          # Replace wildcards with specific ARNs
          "arn:aws:s3:::specific-bucket/*",
          "arn:aws:s3:::specific-bucket"
        ]
      }}
    ]
  }})
}}

'''
        return template

    def _generate_trust_policy_templates(self, findings: Dict, output_dir: str) -> None:
        """Generate secure trust policy templates"""
        excessive_trust = findings.get('excessive_trust', [])

        if excessive_trust:
            template = self._create_trust_policy_template(excessive_trust)
            with open(f'{output_dir}/secure_trust_policies.tf', 'w') as f:
                f.write(template)

    def _create_trust_policy_template(self, findings: List[Dict]) -> str:
        """Create Terraform template for secure trust policies"""
        template = '''# Secure IAM Trust Policies
# Generated by CloudGuardStack IAM Entitlement Scanner
# Replace excessive trust policies with these secure alternatives

'''

        for finding in findings:
            role_name = finding.get('role_name')
            trust_issues = finding.get('trust_issues', [])

            template += f'''
# Secure trust policy for {role_name}
resource "aws_iam_role" "{role_name.replace('-', '_')}_secure" {{
  name = "{role_name}"
  
  assume_role_policy = jsonencode({{
    Version = "2012-10-17"
    Statement = [
      {{
        Effect = "Allow"
        Principal = {{
          # TODO: Replace wildcards with specific principals
          # Example: Specific AWS service or account
          Service = "ec2.amazonaws.com"
          # AWS = "arn:aws:iam::123456789012:role/specific-role"
        }}
        Action = "sts:AssumeRole"
        Condition = {{
          # Add conditions for additional security
          # Bool = {{
          #   "aws:MultiFactorAuthPresent" = "true"
          # }}
          # IpAddress = {{
          #   "aws:SourceIp" = ["10.0.0.0/16"]
          # }}
        }}
      }}
    ]
  }})
}}

'''
        return template

    def _generate_cleanup_templates(self, findings: Dict, output_dir: str) -> None:
        """Generate cleanup templates for unused entities"""
        unused_roles = findings.get('unused_roles', [])

        if unused_roles:
            template = self._create_cleanup_template(unused_roles)
            with open(f'{output_dir}/unused_entities_cleanup.tf', 'w') as f:
                f.write(template)

    def _create_cleanup_template(self, findings: List[Dict]) -> str:
        """Create Terraform template for cleaning up unused entities"""
        template = '''# Unused IAM Entities Cleanup
# Generated by CloudGuardStack IAM Entitlement Scanner
# Remove unused IAM roles to reduce attack surface

'''

        for finding in findings:
            entity_name = finding.get('entity_name')
            entity_type = finding.get('entity_type')
            days_since_creation = finding.get('days_since_creation', 0)

            if entity_type == 'role' and days_since_creation > 90:
                template += f'''
# Remove unused role: {entity_name} (created {days_since_creation} days ago)
# resource "aws_iam_role" "{entity_name.replace('-', '_')}" {{
#   name = "{entity_name}"
#   # This resource is commented out for safety
#   # Uncomment and run 'terraform destroy' to remove
# }}

'''
        template += '''
# Safety Note:
# Before removing any IAM roles, ensure:
# 1. No active resources are using these roles
# 2. No applications depend on these roles
# 3. You have backups of important policies
# 4. You understand the impact of removal

'''
        return template

    def generate_remediation_report(self, output_file: str = 'remediation_plan.md') -> None:
        """Generate markdown remediation report"""
        report = self._create_remediation_report()

        with open(output_file, 'w') as f:
            f.write(report)

        print(f"ðŸ“‹ Remediation plan generated: {output_file}")

    def _normalize_actions(self, actions: Union[str, List[str]]) -> List[str]:
        """Normalize actions to a list of strings"""
        if not actions:
            return []
        if isinstance(actions, str):
            return [actions]
        return actions

    def _actions_match(self, policy_action: str, used_action: str) -> bool:
        """Check if a policy action matches a used action (supports wildcards)"""
        if policy_action == used_action:
            return True
        if '*' in policy_action:
            return matches_action_pattern(policy_action, used_action)
        return False

    def generate_least_privilege_policy(self, current_policy: Dict, used_actions: List[str]) -> Dict:
        """
        Generate a least privilege IAM policy based on used actions.
        
        Args:
            current_policy: The current IAM policy document
            used_actions: List of actions that are actually used
            
        Returns:
            dict: A new IAM policy document with least privilege permissions
        """
        if not isinstance(current_policy, dict) or 'Statement' not in current_policy:
            raise ValueError("Invalid policy format")
            
        new_policy = {
            'Version': current_policy.get('Version', '2012-10-17'),
            'Statement': []
        }
        
        used_actions_set = set(self._normalize_actions(used_actions))
        
        # Process each statement in the current policy
        for stmt in current_policy.get('Statement', []):
            new_stmt = stmt.copy()
            
            # Check if Effect is 'Allow' AND 'Action' is present
            if stmt.get('Effect') == 'Allow' and 'Action' in stmt:
                policy_actions = self._normalize_actions(stmt['Action'])
                matched_actions = []
                
                # Find all used actions that match any of the policy actions
                for policy_action in policy_actions:
                    for used_action in used_actions_set:
                        if self._actions_match(policy_action, used_action):
                            if used_action not in matched_actions:
                                matched_actions.append(used_action)
                
                # FIX: Only add the statement if there are matched actions
                if matched_actions:
                    # Keep the action list format correct (string if one, list if many)
                    new_stmt['Action'] = matched_actions[0] if len(matched_actions) == 1 else matched_actions
                    new_policy['Statement'].append(new_stmt)
            else:
                # Keep Deny statements and other effects as-is
                new_policy['Statement'].append(new_stmt)
                
        return new_policy

    def create_remediation_plan(self, findings):
        """
        Create a remediation plan based on findings.
        
        Args:
            findings: List of IAM findings to remediate
            
        Returns:
            dict: A remediation plan with actions to take
        """
        plan = {
            'remediations': [],
            'timestamp': datetime.now(UTC).isoformat()
        }
        
        if not isinstance(findings, list):
            return plan  # Return empty plan with proper structure
        
        for finding in findings:
            if not isinstance(finding, dict):
                continue
                
            remediation = {
                'entity_name': finding.get('principal') or finding.get('entity_name'),
                'entity_arn': finding.get('entity_arn'),
                'entity_type': finding.get('entity_type'),
                'findings': finding.get('findings', []),
                'status': 'pending',
                'actions': []
            }
            
            # Add remediation actions based on finding type
            if finding.get('finding_type') == 'over_privileged':
                remediation['actions'].append({
                    'type': 'update_policy',
                    'description': 'Update IAM policy to implement least privilege',
                    'status': 'pending',
                    # Policy data can be embedded for completeness/future use
                    'policy_name': finding.get('policy_name'),
                    'current_policy_document': finding.get('current_policy_document'),
                    'used_actions': [f['action'] for f in finding.get('findings', []) if f.get('used')]
                })
            elif finding.get('finding_type') == 'unused_entity':
                remediation['actions'].append({
                    'type': 'delete_entity',
                    'description': 'Remove unused IAM entity',
                    'status': 'pending'
                })
                
            plan['remediations'].append(remediation)
            
        return plan

    def apply_remediation_plan(self, plan, dry_run=False):
        """
        Apply a remediation plan to fix IAM issues.
        
        Args:
            plan: The remediation plan to execute
            dry_run: If True, only simulate the changes
            
        Returns:
            list: Results of each remediation action
        """
        results = []
        
        for remediation in plan.get('remediations', []):
            result = {
                'principal': remediation.get('entity_name'), 
                'entity_arn': remediation.get('entity_arn'),
                'status': 'success',
                'error': None,
                'actions': []
            }
            
            try:
                for action in remediation.get('actions', []):
                    action_result = {
                        'type': action['type'],
                        'status': 'skipped' if dry_run else 'applied',
                        'dry_run': dry_run
                    }
                    
                    if dry_run:
                        result['actions'].append(action_result)
                        continue
                        
                    try:
                        if action['type'] == 'update_policy':
                            if not self.iam:
                                raise Exception("API Error: IAM client is not initialized")
                            
                            role_name = remediation.get('entity_name')
                            if not role_name:
                                raise Exception("API Error: Missing role name in remediation")
                                
                            policy_name = action.get('policy_name', remediation.get('policy_name', 'default'))
                            
                            # Get the current policy
                            response = self.iam.get_role_policy(
                                RoleName=role_name,
                                PolicyName=policy_name
                            )
                            
                            # Handle response
                            if hasattr(response, 'get'):
                                policy_doc = response.get('PolicyDocument')
                                current_policy = json.loads(policy_doc) if isinstance(policy_doc, str) else policy_doc
                            else:
                                current_policy = response
                            
                            # Generate and apply new policy
                            used_actions = action.get('used_actions', remediation.get('actions', []))
                            new_policy = self.generate_least_privilege_policy(current_policy, used_actions)
                            
                            self.iam.put_role_policy(
                                RoleName=role_name,
                                PolicyName=policy_name,
                                PolicyDocument=json.dumps(new_policy, indent=2)
                            )
                            
                            action_result['details'] = 'Policy updated successfully'
                            
                        elif action['type'] == 'delete_entity':
                            # Placeholder for actual delete logic
                            action_result['details'] = 'Entity would be deleted (dry run)' if dry_run else 'Entity deleted successfully'
                            
                        else:
                            action_result.update({
                                'status': 'skipped',
                                'error': f"Unsupported action type: {action['type']}",
                                'details': f"Action type {action['type']} is not implemented"
                            })
                            
                    except Exception as e:
                        error_msg = str(e)
                        if not error_msg.startswith("API Error:"):
                            error_msg = f"API Error: {error_msg}"
                        
                        action_result.update({
                            'status': 'error',
                            'error': error_msg,
                            'details': f"Failed to execute action: {error_msg}"
                        })
                        
                        result.update({
                            'status': 'error',
                            'error': error_msg,
                            'message': error_msg
                        })
                    
                    result['actions'].append(action_result)
                    
            except Exception as e:
                error_msg = str(e)
                result.update({
                    'status': 'error',
                    'error': error_msg,
                    'message': error_msg,
                    'actions': result.get('actions', []) + [{
                        'type': 'error',
                        'status': 'error',
                        'error': error_msg,
                        'dry_run': dry_run,
                        'details': f"Unexpected error: {error_msg}"
                    }]
                })
                
            results.append(result)
            
        return results

    def _create_remediation_report(self):
        """Create comprehensive remediation report"""
        findings = self.entitlement_report.get('findings', {})
        risk_scores = self.entitlement_report.get('risk_scores', {})
        metadata = self.entitlement_report.get('scan_metadata', {})
        summary = self.entitlement_report.get('summary', {})

        report = f'''# IAM Entitlement Remediation Plan
Generated by CloudGuardStack IAM Entitlement Scanner

## Executive Summary

- **Total Entities**: {metadata.get('entities_scanned', 0)}
- **Total Findings**: {metadata.get('total_findings', 0)}
- **Critical Findings**: {summary.get('critical_findings', 0)}
- **High Findings**: {summary.get('high_findings', 0)}

## Priority Remediation Actions

### 1. Critical Issues (Immediate Action Required)

'''

        # Add critical findings
        critical_findings = []
        critical_findings.extend(findings.get('excessive_trust', []))
        critical_findings.extend(findings.get('cross_account_risks', []))

        for finding in critical_findings:
            entity_name = finding.get('role_name') or finding.get('entity_name')
            issue = finding.get('trust_issues', [{}])[0].get('issue', 'Excessive trust')
            report += f'''#### {entity_name}
- **Issue**: {issue}
- **Remediation**: Restrict trust policy to specific principals
- **Timeline**: IMMEDIATE

'''

        report += '''
### 2. High Priority Issues (Action within 1 week)

'''
        # Add high priority findings
        high_findings = findings.get('over_privileged_roles', [])
        for finding in high_findings:
            entity_name = finding.get('entity_name')
            admin_count = len(finding.get('admin_permissions', []))
            report += f'''#### {entity_name}
- **Issue**: {admin_count} administrative permissions
- **Remediation**: Implement least-privilege principle
- **Timeline**: 1 week

'''

        report += '''
## Implementation Steps

### Phase 1: Critical Trust Policy Remediation (Days 1-2)
1. Review and update trust policies for critical roles
2. Replace wildcard principals with specific ARNs
3. Test role functionality after changes

### Phase 2: Least Privilege Implementation (Days 3-7)
1. Create custom IAM policies with minimal permissions
2. Replace administrative policies
3. Monitor for permission denied errors
4. Iteratively adjust policies as needed

### Phase 3: Cleanup and Optimization (Days 8-14)
1. Remove unused IAM roles
2. Archive policy versions
3. Document final IAM architecture

## Risk Assessment

The following entities pose the highest risk and should be addressed first:

'''

        top_risky = sorted(risk_scores.items(), key=lambda x: x[1], reverse=True)[:5]
        for entity, score in top_risky:
            report += f'- **{entity}**: Risk Score {score}\n'

        report += '''
## Success Metrics

- [ ] 100% of critical findings remediated
- [ ] 80% reduction in administrative permissions
- [ ] All trust policies restrict to specific principals
- [ ] Unused roles removed from environment
- [ ] No permission denied errors in production

---
*This remediation plan was automatically generated by CloudGuardStack*
'''
        return report


def main():
    """Main function for generating remediation templates"""
    import argparse

    parser = argparse.ArgumentParser(description='IAM Remediation Template Generator')
    parser.add_argument('--report', default='entitlement_report.json', help='Entitlement report file')
    parser.add_argument('--output-dir', default='remediation_templates', help='Output directory for templates')
    parser.add_argument('--generate-plan', action='store_true', help='Generate remediation plan')

    args = parser.parse_args()

    # Load report
    with open(args.report, 'r') as f:
        report = json.load(f)

    # Generate templates
    generator = RemediationGenerator(report)
    generator.generate_terraform_templates(args.output_dir)

    if args.generate_plan:
        generator.generate_remediation_report()


if __name__ == '__main__':
    main()